---
title: Comandos Bash ğŸ’» (BÃ¡sicos)
summary: Comandos Bash nivel bÃ¡sico
category: linux
tags:
  options:
    - bash
    - terminal
    - zsh
    - linux
draft: false
publishedAt: "2021-09-24T22:00:00.000Z"
---

## Primeros Comandos, Navegando por el Sistema de Archivos

Los sistemas de archivos modernos tienen Ã¡rboles de directorios (carpetas), donde un directorio es un directorio raÃ­z (sin directorio padre) o es un subdirectorio (contenido dentro de otro directorio, al que llamamos "padre"). Si se recorre el Ã¡rbol de archivos hacia atrÃ¡s (desde el directorio hijo hasta el directorio padre) siempre se llegarÃ¡ al directorio raÃ­z. Algunos sistemas de archivos tienen mÃºltiples directorios raÃ­z (como las unidades de Windows: `C:\`, `A:\,` etc.), pero los sistemas Unix y similares sÃ³lo tienen un Ãºnico directorio raÃ­z llamado `\`.

### `pwd / ls / cd`

Cuando se trabaja dentro de un sistema de archivos, el usuario siempre estÃ¡ trabajando dentro de algÃºn directorio, al que llamamos directorio actual o directorio de trabajo. Imprime el directorio de trabajo del usuario con pwd:

```bash
$ pwd
/home/andrew
```

Listar el contenido de este directorio (archivos y/o directorios hijos, etc.) con ls:

```bash
$ ls
Git  TEST  jdoc  test  test.file
```

> - Mostrar archivos ocultos (".") con `ls -a`
> - Mostrar los detalles de los archivos con `ls -l`
> - Combinar varios indicadores como `ls -l -a`
> - A veces se pueden encadenar banderas como `ls -la` en lugar de `ls -l -a`

Cambia de directorio con cd

```bash

$ cd TEST/

$ pwd
/home/andrew/TEST

$ cd A

$ pwd
/home/andrew/TEST/A
```

`cd ..` es la abreviatura de "cd al directorio padre":

```bash
$ cd ..

$ pwd
/home/andrew/TEST
```

`cd ~` o simplemente `cd` es la abreviatura de "cd a mi directorio personal" (/home/nombredeusuario):

```bash
$ cd

$ pwd
/home/andrew
```

- `cd ~user` significa `cd` al directorio principal del usuario
- Puede saltar varios niveles de directorio con `cd ../..`, etc.
- Vuelve al directorio mÃ¡s reciente con `cd -`
- `.` es la abreviatura de "este directorio", asÃ­ que `cd .` no harÃ¡ nada

### `; / && / &`

Las cosas que escribimos en la lÃ­nea de comandos se llaman comandos, y siempre ejecutan algÃºn cÃ³digo mÃ¡quina almacenado en algÃºn lugar de tu ordenador. A veces este cÃ³digo de mÃ¡quina es un comando incorporado de Linux, a veces es una aplicaciÃ³n, a veces es algÃºn cÃ³digo que escribiste tÃº mismo. Ocasionalmente, querremos ejecutar un comando justo despuÃ©s de otro. Para hacer eso, podemos usar `;`

```bash
$ ls; pwd
Git  TEST  jdoc  test  test.file
/home/andrew
```

En el ejemplo anterior, punto y coma significa que primero (ls) lista el contenido del directorio de trabajo, y luego (pwd) imprime su ubicaciÃ³n.

Otra herramienta Ãºtil para encadenar comandos es `&&`. Con `&&`, el comando de la derecha no se ejecutarÃ¡ si el comando de la izquierda falla. `;` y `&&` pueden utilizarse varias veces en la misma lÃ­nea:

```bash
# whoops!
$ cd /Giit/Parser && pwd && ls && cd
-bash: cd: /Giit/Parser: No such file or directory

# el primer comando funcion ahora, asÃ­ que se ejecuta el siguiente
$ cd Git/Parser/ && pwd && ls && cd
/home/andrew/Git/Parser
README.md  doc.sh  pom.xml  resource  run.sh  shell.sh  source  src  target
```

pero con `;`, el segundo comando se ejecutarÃ¡ incluso si el primero falla:

```bash
# pwd y ls se ejecutarÃ¡n aÃºn si cd falla
$ cd /Giit/Parser ; pwd ; ls
-bash: cd: /Giit/Parser: No such file or directory
/home/andrew
Git  TEST  jdoc  test  test.file
```

`&` se parece a `&&` pero en realidad cumple una funciÃ³n completamente diferente. Normalmente, cuando se ejecuta un comando de larga duraciÃ³n, la lÃ­nea de comandos espera a que ese comando termine antes de permitirle introducir otro. Poner `&` despuÃ©s de un comando evita que esto ocurra, y te permite ejecutar un nuevo comando mientras uno anterior sigue en marcha:

```bash
$ cd Git/Parser && mvn package & cd
[1] 9263
```

> Cuando usamos `&` despuÃ©s de un comando para "ocultarlo", decimos que el trabajo estÃ¡ "en segundo plano". Para ver quÃ© trabajos en segundo plano se estÃ¡n ejecutando actualmente, podemos utilizar el comando `jobs`:

```bash
$ jobs
[1]+ Running cd Git/Parser/ && mvn package &
```

## CÃ³mo obtener ayuda

### `-h`

Escribe `-h` o `--help` despuÃ©s de casi cualquier comando para que aparezca un menÃº de ayuda para ese comando:

```bash
$ du --help
Usage: du [OPTION]... [FILE]...
  or:  du [OPTION]... --files0-from=F
Summarize disk usage of the set of FILEs, recursively for directories.

Mandatory arguments to long options are mandatory for short options too.
  -0, --null            end each output line with NUL, not newline
  -a, --all             write counts for all files, not just directories
      --apparent-size   print apparent sizes, rather than disk usage; although
                          the apparent size is usually smaller, it may be
                          larger due to holes in ('sparse') files, internal
                          fragmentation, indirect blocks, and the like
  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,
                           '-BM' prints sizes in units of 1,048,576 bytes;
                           see SIZE format below
...
```

### `man`

Escribe `man` antes de casi cualquier comando para que aparezca el manual de ese comando (salga de man con `q`):

```bash
LS(1)                            User Commands                           LS(1)

NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List  information  about  the FILEs (the current directory by default).
       Sort entries alphabetically if none of -cftuvSUX nor --sort  is  speci-
       fied.

       Mandatory  arguments  to  long  options are mandatory for short options
       too.
...
```

## VisualizaciÃ³n y ediciÃ³n de archivos

### `head / tail / cat / less`

`head` muestra las primeras lÃ­neas de un archivo. La bandera `-n` especifica el nÃºmero de lÃ­neas a mostrar (el valor por defecto es 10):

```bash
# Imprime las primeras tres lÃ­neas
$ head -n 3 c
this
file
has
```

`tail` muestra las Ãºltimas lÃ­neas de un archivo. Puedes obtener las Ãºltimas `n` lÃ­neas (como en el caso anterior), o puedes obtener el final del archivo a partir de la NÂª lÃ­nea con tail -n +N:

```bash
# imprime el final del archivo empezando por la cuarta lÃ­nea
$ tail -n +4 c
exactly
six
lines
```

`cat` concatena una lista de archivos y los envÃ­a al flujo de salida estÃ¡ndar (normalmente el terminal). `cat` puede usarse con un solo archivo, o con varios, y a menudo se utiliza para verlos rÃ¡pidamente.

```bash
$ cat a
file a

$ cat a b
file a
file b
```

`less` es otra herramienta para ver rÃ¡pidamente un archivo, abre una ventana de sÃ³lo lectura similar a la de vim.

### `nano / nedit`

`nano` es un editor de texto de lÃ­nea de comandos minimalista. Es un gran editor para los principiantes o la gente que no quiere aprender un millÃ³n de atajos.

`nedit` es un pequeÃ±o editor grÃ¡fico, que abre una ventana X y permite la ediciÃ³n de apuntar y hacer clic, arrastrar y soltar, resaltar la sintaxis y mÃ¡s. Podemos usar `nedit` para hacer pequeÃ±os cambios en un script y volver a ejecutarlo una y otra vez.

Otros editores comunes de CLI (interfaz de lÃ­nea de comandos) / GUI (interfaz grÃ¡fica de usuario) son `emacs`, `vi`, `vim`, `gedit`, `Notepad++`, `Atom`, o `VS Code`y muchos mÃ¡s.

Todos los editores modernos ofrecen comodidades bÃ¡sicas como buscar y reemplazar, resaltar la sintaxis, etc. vi(m) y emacs tienen mÃ¡s caracterÃ­sticas que nano y nedit, pero tienen una curva de aprendizaje mucho mÃ¡s pronunciada.

## CreaciÃ³n y eliminaciÃ³n de archivos y directorios

### `touch`

`touch` fue creado para modificar las marcas de tiempo de los archivos, pero tambiÃ©n puede utilizarse para crear rÃ¡pidamente un archivo vacÃ­o. Puedes crear un nuevo archivo abriÃ©ndolo con un editor de texto, como `nano`:

```bash
$ ls

$ nano a
```

```bash
$ touch b && ls
a  b
```

### `mkdir / rm / rmdir`

## Mover y copiar archivos, hacer enlaces, historial de comandos

### `mv / cp / ln`

`mkdir` se utiliza para crear nuevos directorios vacÃ­os:

```bash
$ ls && mkdir c && ls
a  b
a  b  c
```

Puedes eliminar cualquier archivo con `rm` -- Â¡pero ten cuidado, esto no es recuperable!

```bash
$ rm a && ls
b  c
```

Puedes aÃ±adir un aviso de "Â¿estÃ¡ seguro?" con la bandera `-i`:

```bash
$ rm -i b
rm: remove regular empty file 'b'? y
```

Eliminar un directorio vacÃ­o con `rmdir`. Si `ls -a` en un directorio vacÃ­o, sÃ³lo deberÃ­a ver una referencia al propio directorio (.) y una referencia a su directorio padre (..):

```bash
$ rmdir c && ls -a
.  ..
```

`rmdir` sÃ³lo elimina los directorios vacÃ­os:

```bash
$ cd .. && ls test/
*.txt  0.txt  1.txt  a  a.txt  b  c

$ rmdir test/
rmdir: failed to remove 'test/': Directory not empty
```

Pero puedes eliminar un directorio y todo su contenido con `rm -rf` (-r = recursivo, -f = forzado):

```bash
$ rm â€“rf test
```

### Historial de comandos

`bash` tiene dos grandes caracterÃ­sticas para ayudarte a completar y volver a ejecutar comandos, la primera es la finalizaciÃ³n de tabulaciÃ³n. Simplemente escribe la primera parte de un comando, pulsa la tecla`tab` y deja que el terminal adivine lo que estÃ¡s tratando de hacer:

```bash
$ ls <ENTER>
anotherlongfilename  thisisalongfilename  anewfilename

$ ls t <TAB>
```

pulsa la tecla `tab` despuÃ©s de escribir ls t y el comando se completarÃ¡...

```bash
$ ls thisisalongfilename <ENTER>
thisisalongfilename
```

Puede que tengas que pulsar `tab` varias veces si hay una ambigÃ¼edad:

```bash
$ ls a <TAB>

$ ls an <TAB>
anewfilename  anotherlongfilename
```

`bash` mantiene un breve historial de los comandos que has escrito anteriormente y te permite buscar entre esos comandos escribiendo ^r (Ctrl+r):

```bash
(reverse-i-search)`':
```

escribe 'anew' y se encuentra el Ãºltimo comando que contiene esto...

```bash
(reverse-i-search)`anew': touch anewfilename
```

## Ãrboles de directorios, uso del disco y procesos

### `mkdir â€“p / tree`

`mkdir`, por defecto, sÃ³lo hace un Ãºnico directorio. Esto significa que si, por ejemplo, el directorio d/e no existe, entonces d/e/f no puede hacerse con mkdir por sÃ­ mismo:

```bash
$ ls && mkdir d/e/f
a  b  c
mkdir: cannot create directory 'd/e/f': No such file or directory
```

Pero si pasamos la bandera `-p` a mkdir, harÃ¡ todos los directorios de la ruta si no existen ya:

```bash
$ mkdir -p d/e/f && ls
a  b  c  d
```

`tree` puede ayudarte a visualizar mejor la estructura de un directorio imprimiendo un Ã¡rbol de directorios con un buen formato. Por defecto, imprime toda la estructura del Ã¡rbol (empezando por el directorio especificado), pero puede restringirla a un nÃºmero determinado de niveles con la bandera -L:

```bash
$ tree -L 2
.
|-- a
|-- b
|-- c
`-- d
    `--e

3 directories, 2 files
```

Puedes ocultar los directorios vacÃ­os en la salida de `tree` con `--prune`. Ten en cuenta que esto tambiÃ©n elimina los directorios "recursivamente vacÃ­os", o los directorios que no estÃ¡n vacÃ­os en sÃ­ mismos, pero que sÃ³lo contienen otros directorios vacÃ­os, u otros directorios recursivamente vacÃ­os:

```bash
$ tree --prune
.
|-- a
`-- b
```

### `df / du / ps`

`df` se utiliza para mostrar cuÃ¡nto espacio ocupan los archivos de los discos o de su sistema (discos duros, etc.).

```bash
$ df -h
Filesystem                   Size  Used Avail Use% Mounted on
udev                         126G     0  126G   0% /dev
tmpfs                         26G  2.0G   24G   8% /run
/dev/mapper/ubuntu--vg-root  1.6T  1.3T  252G  84% /
...
```

En el comando anterior, `-h` no significa "ayuda", sino "lectura humana". Algunos comandos utilizan esta convenciÃ³n para mostrar el tamaÃ±o de los archivos/disco con K para kilobytes, G para gigabytes, y asÃ­ sucesivamente, en lugar de escribir un gigantesco nÃºmero entero de bytes.

`du` muestra el uso del espacio de archivos para un directorio en particular y sus subdirectorios. Si quieres saber cuÃ¡nto espacio estÃ¡ libre en un disco duro determinado, utiliza `df`; si quieres saber cuÃ¡nto espacio estÃ¡ ocupando un directorio, utiliza `du`:

```bash
$ du
4       ./d/e/f
8       ./d/e
12      ./d
4       ./c
20      .
```

`du` toma una bandera `--max-depth=N`, que sÃ³lo muestra los directorios N niveles abajo (o menos) del directorio especificado:

```bash
$ du -h --max-depth=1
12K     ./d
4.0K    ./c
20K     .
```

`ps` muestra todos los procesos del usuario que se estÃ¡n ejecutando actualmente (tambiÃ©n conocidos como trabajos):

```bash
$ ps
  PID TTY          TIME CMD
16642 pts/15   00:00:00 ps
25409 pts/15   00:00:00 bash
```

## Miscellaneous

### `passwd / logout / exit`

Cambia la contraseÃ±a de tu cuenta con `passwd`. Te pedirÃ¡ tu contraseÃ±a actual para verificarla, y luego te pedirÃ¡ que introduzcas la nueva contraseÃ±a dos veces, para que no cometas ningÃºn error:

```bash
$ passwd
Changing password for andrew.
(current) UNIX password:    <type current password>
Enter new UNIX password:    <type new password>
Retype new UNIX password:   <type new password again>
passwd: password updated successfully
```

`logout` sale de un shell en el que has entrado (donde tienes una cuenta de usuario):

```bash
$ logout

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Session stopped
    - Press <return> to exit tab
    - Press R to restart session
    - Press S to save terminal output to file
```

`exit` sale de cualquier tipo de shell:

```bash
$ exit
logout

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Session stopped
    - Press <return> to exit tab
    - Press R to restart session
    - Press S to save terminal output to file
```

### `clear / *`

Ejecuta `clear` para mover la lÃ­nea actual del terminal a la parte superior de la pantalla. Este comando sÃ³lo agrega lÃ­neas en blanco debajo de la lÃ­nea actual del prompt. Es bueno para limpiar su espacio de trabajo.

Utilice el glob (\*, aka. Kleene Star, aka. wildcard) cuando busques archivos. Observe la diferencia entre los dos comandos siguientes:

```bash
$ ls Git/Parser/source/
PArrayUtils.java     PFile.java            PSQLFile.java      PWatchman.java
PDateTimeUtils.java  PFixedWidthFile.java  PStringUtils.java  PXSVFile.java
PDelimitedFile.java  PNode.java            PTextFile.java     Parser.java

$ ls Git/Parser/source/PD*
Git/Parser/source/PDateTimeUtils.java  Git/Parser/source/PDelimitedFile.java
```

`glob` se puede utilizar varias veces en un comando y coincide con cero o mÃ¡s caracteres:

```bash
$ ls Git/Parser/source/P*D*m*
Git/Parser/source/PDateTimeUtils.java  Git/Parser/source/PDelimitedFile.java
```

â¤ï¸ Espero que te haya gustado la entrada.

Puedes continuar leyendo el siguiente capÃ­tulo sobre [Comandos Intermedios](/blog/linux/101-comandos-bash-intermedios), o volver al [Ãndice](/blog/linux/101-comandos-bash)
